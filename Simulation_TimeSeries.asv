
% clear
% clc
% close all

% Contol Simulation Settings

use_filtered_data = false;
consider_all_strips = true;
DT = 10; % Time step of the data expressed in minutes


strip_radii = [45.15 49.25 53 56.05 58.75 60.8]; % Strips, indexed 1 to 6 of those considered in the paper

strip_index = 6; % Index of strip being considered

if use_filtered_data
    suffix = "filt";
else
    suffix = "unfilt";
end

if consider_all_strips
    num_loops = 1:length(strip_radii);
else
    num_loops = strip_index;
end


for i = num_loops

% Load in time series data:
imported_structure = struct2cell(load(append("Simulation_Data\Time_Series\",string(DT),"min_data_",suffix,".mat")));% Using the non-filtered data to match the joint FDF
wind_droplet_table = imported_structure{1};

% In my meeting with S we discussed moving all the data from the last
% droplet diameter bin into the second last due to the fact the bins are
% only defined for the lower value of each bin, I will ignore this for now

d_bins = imported_structure{2}; % The bins provided are for the lower value of each bin. 
terminal_v_bins = imported_structure{3}; % The bins are provided for the upper value of each bin so add leading 0

%wind_droplet_table = RestructureTable(wind_droplet_table); % Adjusts the table so that the correct time frame is used


% Generates a vector of the variables of the joint size velocity
% distribution indexes
for x = 1:440
    svd_indexing(x) = append("svd_",string(x-1));
end

% Gets the collumns of the joint SVD from the table
svd = wind_droplet_table{:,svd_indexing};
svdSize = size(svd);

% Gives a matrix with terminal velocities on the first axis and droplet diameters on the second
svd = reshape(svd', 20, 22, svdSize(1));  



% The diameters and velocities assosiated with each of the bins in svd 
d_calculations = d_bins; 

t_v_lower = [0 terminal_v_bins(1:end-1)];
t_v_calculations = (terminal_v_bins + t_v_lower)./2; % Currently Gets the midpoint of each of the terminal velocities



% Wind speed at each timestep
wind_velocities = wind_droplet_table{:,"wind_avg"};

simplify_to_fdf = true; % Controls if the exact wind speed is used or if the same bins as used in the RENER joint FDF are used
 
if simplify_to_fdf
 [w_mids,d_lowers] = LoadMeasuredDSD("Simulation_Data\RENER2024\myMap_turbine.mat");
 [~, indices] = min(abs(wind_velocities(:) - w_mids), [], 2); % Gets for each exact wind velocity, the index of the wind velocity that is the bin this velocity falls under
 wind_velocities = w_mids(indices)';

end

% Convert the wind speeds to the corresponding speed of the blade at a
% each index

blade_velocities = WindToBladeVelocity(wind_velocities,strip_radii(i));

% Create matrix of number of droplets incident on blade per m^2
A = 0.0046; % area in m^2 of sensor

[svd_diameters,svd_vels] = meshgrid(d_calculations,t_v_calculations); % Creates grid with 1-1 correspondence with the Size-Velocity Distribution with the droplet size and velocity at each point

svd_vels = 1; % Initially assume that droplet diameters are all 1 m/s - to match with RENER. Remove this line to consider droplet terminal velocities.
svd = svd./(A.*svd_vels); % Area converts from Impacts to per m^2, then the terminal velocity of the drops gives per m^3 (Time ommited as it cancels later - see Incident_Droplet_Calculations.pdf for an explanation)

n_droplets_air = sum(svd,1); % Sum across all droplet terminal velocities

n_droplets_air = permute(n_droplets_air,[3 2 1]); % Remove droplet terminal velocity dimension

n_s = n_droplets_air .* blade_velocities; % Convert back to per m^2 with the blade velocities (Ensuring data is along correct axis)


% Now creates a matrix with both the droplet diameters and blade velocities
% for every droplet diameter bin for every time step.
[diameter_mesh,blade_vel_mesh] = meshgrid(d_calculations,blade_velocities); 


computed_vals = GetSpringerStrength(); % Sets up the springer strength (Given in the RENER paper)

allowed_impingements = CalculateAllowedImpingements(computed_vals,blade_vel_mesh,diameter_mesh); % Calculates the allowed impingements for each blade velocity and diameter combination

damages = n_s./allowed_impingements; 

time_series_damage = sum(damages,2); % Gets the damage for every timestep

droplet_diameter_damage = sum(damages,1);

cumSumDamages = cumsum(time_series_damage); % Vector of the accumalated damage over time

total_damage = sum(damages,'all');

strip_hours(i) = (1/total_damage)*356*24;

end




% disp(['The total damage caused to the turbine is: ', num2str(total_damage)])
% Hours  = (1/total_damage)*356*24;
% disp(['Number of Hours for Incubation ', num2str(Hours)])

ans1 = strip_hours

ref_lifetimes = [34891 21156 13408 9402 7186 5509];


ans2 = 100.*(abs(strip_hours-ref_lifetimes)./ref_lifetimes)

if simplify_to_fdf
% Re-construct FDF:
 
 FDF = zeros(length(w_mids),length(d_lowers));
 
 for x=1:length(w_mids)
     rows = n_droplets_air(w_mids==w_mids(x),:);
     FDF(x,:) = sum(rows,1);
 
 end
 d_bins = [0 d_lowers ] % An incorrect display of the data but it is consistent with the rener
 SpeedDropletPlot(d_bins,FDF,"FDF - created");

end

%disp(['Percentage difference between Predicted and Reference:', num2str(100*(abs(Hours-ref_lifetimes(strip_index))/ref_lifetimes(strip_index)))])
plot(d_calculations,droplet_diameter_damage);


function new_table = RestructureTable(input_table)

    % This function removes data not in the domain of the 1 year we are
    % looking for. 

    t_vals = input_table{:,"dateTime"};
    t_vals = datetime(t_vals);



    % Now fill in the missing data

    % Data needs to be copied from the entire month of July in 20

    july_index_start = find(year(t_vals)==2017&month(t_vals)==7,1,"first");
    july_index_end = find(year(t_vals)==2017&month(t_vals)==7,1,"last");

    index_start_insertion = find(year(t_vals)==2019&month(t_vals)==6,1,"last");
    index_end_insertion = find(year(t_vals)==2019&month(t_vals)==8,1,"first");

    data_to_insert = input_table(july_index_start:july_index_end,:);

    updated_timestamps = vertcat(data_to_insert{:,"dateTime"});

    %updated_timestamps = datetime(cell2mat(updated_timestamps));
    updated_timestamps.Year = 2019;
    %updated_timestamps = num2cell(updated_timestamps);

    data_to_insert{:,"dateTime"} = updated_timestamps;





    table_1 = input_table(1:index_start_insertion,:);

    table_2 = input_table(index_end_insertion:end,:);

    input_table = [table_1;data_to_insert;table_2;];

        % Find the indexes in the table that correspond to First time step of
    % October 2018 and last time step of 30 Sep 2019
    t_vals = input_table{:,"dateTime"};
    t_vals = datetime(t_vals);

    target_start_year = 2018;
    target_start_month = 10;
    start_day_index = find(year(t_vals) == target_start_year & month(t_vals) == target_start_month, 1, 'first');

    
    
    target_end_year = 2019;
    target_end_month = 9;
    target_end_day = 30;
    
    end_day_index = find(year(t_vals) == target_end_year & month(t_vals) == target_end_month & day(t_vals) == target_end_day , 1, 'last');



    % In the RENER24 Paper, data is described as missing between the 22nd
    % and 26th of Sep 2019. This is accurate
    % However it says to fill in use the corresponding dates in 2017. This
    % data also does not exist.

    % For now I will ignore as it will be a small modification


    
    new_table = input_table(start_day_index:end_day_index,:);


end

